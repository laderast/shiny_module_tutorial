---
title: "Shiny Modules"
author: "Ted Laderas"
date: "5/12/2019"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why Shiny Modules?

There are two main reasons why you'd want to modularize your shiny code.

1. **Don't Repeat Yourself**. One issue with monolithic Shiny apps is that it is difficult to reuse parts of them. By taking a little more time and designing each part of your app so they are modular with Shiny modules. 

2. **Managing all of the ids in a global namespace is difficult**. Remember that for a shiny app, each ui element needs a unique id. As you add more and more ui elements, it becomes difficult to name and track all of these. Shiny modules give each module pair their own namespace, which means that you can reuse element ids without worry. 

The goal of this document is to get you to the point where you feel comfortable with building and using Shiny Modules in your work.

## Shiny Module Concepts

A Shiny module usually will have two functions: a `ui` functions, and a `server` function. They are tied together by a *namespace* id, so they know what *namespace* to look into. 

A *namespace* can be thought of an isolated little world where you can reuse ids without worries. Say I had two different parts of my application, a histogram, and a scatterplot, and they both have `selectInputs`. If we don't use modules, we have to use unique ids for both of these selectInputs. For example, we might use 

```
selectInput(id = "select_box_histogram")
```
for the histogram, and

```
selectInput(id = "select_box_scatter")
```

for the scatterplot.

Keeping track of these unique ids is a pain. So, let's make two different *namespaces* for each part of these apps, one called `histogram` and one called `scatter`. 

If I have an id called `select_box` in the `histogram` namespace, it will not collide (cause Shiny to throw up its hands in confusion) for an id called `select_box` in the `scatter` namespace.

Another consequence of namespaces is that you can reuse code and have the code each have an independent namespace.

I try to use the naming convention of `MODULENAME_ui` for the `ui` function, and `MODULENAME_server` for the server function. 

## Our Goal

We want to build a reusable module that will make a scatterplot when we pass a data frame into it. Here's our app that uses our module pair, (`select_scatter_ui()` and `select_scatter_server()`). `select_scatter_ui` will take two arguments: the namespace id, and the choices we want to pass into our `selectInput` dropdown. `select_scatter_server()` takes the following arguments: `input`, `output`, `session`, and an additional one we're adding called `data`. 

Try running the app first so you can see what it does.

```{r}
shiny::runApp("module_demo_01")
```

Let's first look at the `app.R` in `module_demo_01` that uses our modules. For simplicity's sake, I've omitted the library calls below.

The first thing to note that we specify the variable `mtcars_id`, which is the id of the namespace shared between the `select_scatter_ui()` and `select_scatter_server()` functions in our module. We're also picking the column name choices for our app by calling `colnames()` on `mtcars`. Then we load our module code.

```
mtcars_id <- "mtcars_mod"
mtcars <- data.frame(mtcars)
mtcars_var_choices = colnames(mtcars)

#load the module code
source("modules.R")
```

In our `ui` function, we directly call our ui module function called `select_scatter_ui()`, and `mtcars_id` is our id argument. We have an additional argument called `var_choices` where we pass our `mtcars_var_choices` in.

```
ui <- fluidPage(
    #select_scatter_ui is how we initialize the ui module with id "mtcars"
    select_scatter_ui(id = mtcars_id, var_choices = mtcars_var_choices)
)
```

In our server function, we're using the `callModule()` function to invoke our server module function, `select_scatter_server()`, passing it `mtcars_id` and `mtcars` as our function. 

```
server <- function(input, output) {
    #callModule on select_scatter_server with id "mtcars"
    callModule(select_scatter_server, mtcars_id, data=mtcars)
}
```

Having specified our `ui` and `server` functions, we run our shiny app as usual:

```
# Run the application 
shinyApp(ui = ui, server = server)
```

Here's the full app.R code for your reference:

```
mtcars_id <- "mtcars_mod"
mtcars <- data.frame(mtcars)
mtcars_var_choices = colnames(mtcars)

#load the module code
source("modules.R")

ui <- fluidPage(
    #select_scatter_ui is how we initialize the ui module with id "mtcars"
    select_scatter_ui(id = mtcars_id, var_choices = mtcars_var_choices)
)

# Define server logic required to draw a histogram
server <- function(input, output) {
    #callModule on select_scatter_server with id "mtcars"
    callModule(select_scatter_server, mtcars_id, data=mtcars)
}

# Run the application 
shinyApp(ui = ui, server = server)
```
# Reusing our code

So what if we want to have two independent instances of our module? They will need separate namespace ids so their elements, such as the `selectInput` UI elements will not collide. Try running `module_demo_02` and notice that it has two instances.

```{r}
shiny::runApp("module_demo_02")
```

In the first part of the code, we specify the elements for each dataset. Our first instance uses `mtcars` as before, and our new instance will use `iris`:

```
data(mtcars)
mtcars_id <- "mtcars_mod"
mtcars <- data.frame(mtcars)
mtcars_var_choices = colnames(mtcars)

data(iris)
iris_id <- "iris_mod"
iris_var_choices <- colnames(iris)
```

In our `ui` function, we call two separate instances of `select_scatter_ui`, each with our separate ids, `mtcars_id` and `iris_id`:

```
ui <- fluidPage(
    #select_scatter_ui is how we initialize the ui module with id "mtcars"
    select_scatter_ui(id = mtcars_id, var_choices = mtcars_var_choices),
    #use select_scatter_ui with iris data
    select_scatter_ui(id = iris_id, var_choices = iris_var_choices)
)
```

In our `server` function, we do the same, except with `callModule`:

```
# Define server logic required to draw a histogram
server <- function(input, output) {
    #callModule on select_scatter_server with mtcars_id
    callModule(select_scatter_server, mtcars_id, data=mtcars)
    #callModule on select_scatter_server with iris_id
    callModule(select_scatter_server, iris_id, data=iris)
}
```

Then our two modules are independent of each other. Neat, huh?

## TODO: Chaining Modules with reactives

## TODO: Nesting Modules
